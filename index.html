<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>CAP Uniform Builder â€” Full Program</title>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<style>
  :root{
    --bg:#eef1f5;
    --ink:#0d1b2a;
    --muted:#516079;
    --panel:#ffffff;
    --line:#cfd6df;
    --brand:#002855;
    --accent:#0062ff;
  }

  *{box-sizing:border-box;margin:0;padding:0}

  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:var(--bg);
    color:var(--ink);
  }

  header{
    background:var(--brand);
    color:#fff;
    padding:14px 16px 14px 48px; /* leave space for hamburger in top-left */
    text-align:center;
    position:relative;
    box-shadow:0 2px 4px rgb(0 0 0 / .3);
    z-index:10;
  }
  header h1{
    margin:0;
    font-size:18px;
    font-weight:600;
    letter-spacing:.3px;
    line-height:1.3;
  }
  header .subtitle{
    font-size:12px;
    font-weight:400;
    opacity:.8;
  }

  /* HAMBURGER MENU BUTTON */
  .hamburgerBtn{
    position:fixed;
    left:12px;
    top:12px;
    z-index:10000;
    width:32px;
    height:32px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.4);
    background:rgba(255,255,255,.12);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:4px;
    cursor:pointer;
    box-shadow:0 10px 25px rgb(0 0 0 / .3);
  }
  .hamburgerBtn span{
    display:block;
    width:18px;
    height:2px;
    background:#fff;
    border-radius:1px;
  }

  /* MAIN LAYOUT SHELL */
  #layoutShell {
    display:flex;
    height:calc(100vh - 58px); /* minus header height */
    position:relative;
    background:var(--bg);
    color:var(--ink);
    overflow:hidden;
  }

  /* SIDEBAR WRAPPER (for drag sizing) */
  .panel-shell{
    display:flex;
    flex-direction:row;
    align-items:stretch;
    min-width:260px;
    max-width:480px;
    position:relative;
    z-index:10;
    transition:
      width .2s ease,
      min-width .2s ease,
      max-width .2s ease,
      transform .2s ease;
  }

  /* Sidebar / Controls panel */
  #controls {
    background:var(--panel);
    border-right:1px solid var(--line);
    box-shadow:0 0 20px rgb(0 0 0 / .07);
    display:flex;
    flex-direction:column;
    min-height:0;
    overflow:hidden;
    border-top-right-radius:0;
    border-bottom-right-radius:0;

    /* resizable default width */
    width:320px;
    min-width:260px;
    max-width:480px;
  }

  /* draggable handle on right edge */
  #panelResizer{
    position:relative;
    flex:0 0 6px;
    cursor:ew-resize;
    background:transparent;
  }
  #panelResizer::after{
    content:"";
    position:absolute;
    top:50%;
    left:2px;
    transform:translateY(-50%);
    width:2px;
    height:40px;
    border-radius:1px;
    background:var(--line);
  }

  /* collapsed state */
  #layoutShell.sidebar-open .panel-shell{
    transform:translateX(0);
    box-shadow:0 0 20px rgb(0 0 0 / .07);
  }
  #layoutShell.sidebar-collapsed .panel-shell{
    transform:translateX(-100%);
    box-shadow:none;
  }

  .controlsHeader {
    background:var(--brand);
    color:#fff;
    padding:12px 14px;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
  }
  .controlsHeader .controlsTitle {
    margin:0;
    font-size:14px;
    font-weight:600;
    line-height:1.2;
    letter-spacing:.2px;
    width:100%;
    text-align:left;
  }
  .controlsHeader .controlsSub{
    font-size:11px;
    font-weight:400;
    opacity:.8;
    line-height:1.3;
  }

  .controlsScrollArea{
    flex:1;
    overflow-y:auto;
    padding:12px 14px 200px; /* leave room above footer & calibration export */
    position:relative;
    min-width:0;
  }

  .panelBlock,
  .panelSection{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:10px;
    padding:12px 12px 10px;
    margin-bottom:12px;
    box-shadow:0 8px 20px rgb(0 0 0 / .04);
  }

  .fieldLabel{
    font-size:13px;
    font-weight:600;
    color:var(--ink);
    display:block;
    margin-bottom:6px;
  }
  .hintText{
    font-size:11px;
    line-height:1.3;
    color:var(--muted);
    margin-top:6px;
  }

  select,button,input{
    width:100%;
    margin-top:6px;
    padding:8px;
    border:1px solid var(--line);
    border-radius:10px;
    background:#f8fafc;
    font-family:inherit;
    font-size:13px;
    color:var(--ink);
  }
  button{
    cursor:pointer;
    background:#0f2a54;
    color:#fff;
    border-color:#163766;
  }
  button.ghost{
    background:#ffffff;
    color:var(--ink);
  }

  .row{display:flex;gap:8px;flex-wrap:wrap}
  .two .col{flex:1}

  .hidden{display:none !important}

  /* uniform selector buttons */
  .uniformList{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .uniformOption{
    width:100%;
    text-align:left;
    background:#fff;
    border:1px solid var(--line);
    border-radius:8px;
    padding:10px 12px;
    font-family:inherit;
    cursor:pointer;
    position:relative;
    box-shadow:0 4px 12px rgb(0 0 0 / .03);
    transition:box-shadow .12s ease,border-color .12s ease,background .12s ease;
  }
  .uniformOption:hover{
    box-shadow:0 10px 24px rgb(0 0 0 / .07);
    border-color:var(--brand);
    background:rgba(0,40,85,.04);
  }
  .uniformOption .uName{
    font-size:13px;
    font-weight:600;
    color:var(--ink);
    margin-bottom:2px;
    line-height:1.3;
  }
  .uniformOption .uDesc{
    font-size:11px;
    color:var(--muted);
    line-height:1.3;
  }

  /* locked (not authorized for this member type) */
  .uniformOption.locked{
    cursor:not-allowed;
    opacity:.45;
    filter:grayscale(1);
    background:#f4f4f7;
    border-style:dashed;
    border-color:var(--line);
    box-shadow:none;
  }
  .uniformOption.locked:hover{
    border-color:var(--line);
    background:#f4f4f7;
    box-shadow:none;
  }
  .uniformOption.locked:hover::after{
    content:attr(data-locked-reason);
    position:absolute;
    left:100%;
    top:50%;
    transform:translate(8px,-50%);
    min-width:180px;
    max-width:220px;
    background:rgba(15,23,42,.95);
    color:#fff;
    font-size:11px;
    line-height:1.35;
    border-radius:8px;
    box-shadow:0 20px 40px rgb(0 0 0 / .6);
    padding:8px 10px;
    border:1px solid rgba(255,255,255,.2);
    pointer-events:none;
    white-space:normal;
    text-align:left;
    z-index:9999;
  }

  /* ===== Ribbon picker grid (McChord-style) ===== */
  .subsection-header{
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    gap:8px;
    margin-bottom:10px;
  }
  .subsection-title{
    font-size:12px;
    font-weight:700;
    color:var(--ink);
    line-height:1.2;
  }
  .subsection-hint{
    font-size:11px;
    font-weight:400;
    color:var(--muted);
    line-height:1.3;
  }

  .ribbonGrid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(140px,1fr));
    gap:12px;
  }
  .ribbonCard{
    border:1px solid var(--line);
    border-radius:8px;
    background:#fff;
    box-shadow:0 4px 12px rgb(0 0 0 / .05);
    padding:10px;
    display:flex;
    flex-direction:column;
    font-size:12px;
    min-width:0;
  }
  .ribbonHeader{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    margin-bottom:8px;
    gap:8px;
  }
  .ribbonLeft{
    display:flex;
    align-items:flex-start;
    gap:6px;
  }
  .ribbonCheck input[type="checkbox"]{
    width:16px;
    height:16px;
    cursor:pointer;
  }
  .ribbonImg{
    width:48px;
    height:14px;
    background:#999;
    border-radius:2px;
    border:1px solid #000;
    flex-shrink:0;
    background-size:cover;
    background-position:center;
  }
  .ribbonName{
    font-size:11px;
    font-weight:600;
    color:var(--ink);
    line-height:1.2;
    word-break:break-word;
    flex:1;
  }
  .ribbonBody{
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .deviceField label{
    font-size:10px;
    font-weight:600;
    color:var(--muted);
    margin-bottom:2px;
    display:block;
  }
  .deviceField select{
    width:100%;
    font-size:12px;
    padding:4px 6px;
    border:1px solid var(--line);
    border-radius:6px;
    background:#fff;
    color:var(--ink);
    min-height:28px;
  }

  /* device multi-apply toolbox */
  #deviceTool{
    margin-top:12px;
    border:1px solid var(--line);
    border-radius:10px;
    padding:10px;
    background:#fefefe;
    font-size:12px;
  }
  #devicePicker{
    display:grid;
    grid-template-columns:repeat(2,minmax(0,1fr));
    gap:8px;
    font-size:12px;
  }

  /* PATCHES / BADGES hint text already covered in panelBlock */

  /* PREVIEW WRAPPER */
  #previewWrapper{
    flex:1;
    position:relative;
    padding:16px;
    display:flex;
    gap:16px;
    overflow:auto;
    align-items:flex-start;
    justify-content:center;
    background:var(--bg);
    min-width:0;
  }

  /* Preview canvas box */
  #previewArea{
    position:relative;
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:12px;
    width:450px;
    height:600px;
    box-shadow:0 30px 60px rgb(0 0 0 / .12);
    overflow:hidden;
    flex-shrink:0;
  }

  #uniformCanvas{
    position:relative;
    width:100%;
    height:100%;
  }
  .layer{
    position:absolute;
    image-rendering:auto;
  }

  /* side display (epaulets etc) */
  #sideDisplay{
    display:flex;
    flex-direction:column;
    gap:16px;
    min-width:140px;
  }

  /* TOOLTIP BUBBLE */
  .tooltipBubble{
    position:fixed;
    z-index:9999;
    min-width:180px;
    max-width:240px;
    background:rgba(15,23,42,.95);
    color:#fff;
    font-size:12px;
    line-height:1.35;
    border-radius:8px;
    box-shadow:0 20px 40px rgb(0 0 0 / .6);
    padding:8px 10px;
    pointer-events:none;
    border:1px solid rgba(255,255,255,.2);
  }
  .tooltipBubble strong{
    font-size:12px;
    font-weight:600;
    color:#fff;
    display:block;
    margin-bottom:4px;
  }
  .tooltipBubble em{
    color:#94a3b8;
    font-style:normal;
    font-size:11px;
  }

  /* Drag calibration visuals */
  .drag-mode-on .ribbonTile{
    outline:1px dashed rgba(0,40,85,.6);
    cursor:move;
    z-index:9999;
  }
  .dragging{
    opacity:.7;
  }

  /* GUIDE DOT (debug aid) */
  .guideDot{
    position:absolute;
    background:rgba(0,40,85,.15);
    border:1px solid rgba(0,40,85,.4);
    color:var(--ink);
    font-size:10px;
    line-height:1.2;
    padding:2px 4px;
    border-radius:4px;
    pointer-events:none;
    white-space:nowrap;
  }

  /* FLOATING RACK CALIB TAB */
  #calibratorWrapper {
    position:fixed;
    top:80px;
    left:0;
    z-index:10001;
    display:flex;
    align-items:flex-start;
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
    color:var(--ink);
  }
  #calibratorTab {
    background:var(--brand);
    color:#fff;
    padding:8px 6px;
    font-size:12px;
    font-weight:600;
    border-top-right-radius:6px;
    border-bottom-right-radius:6px;
    cursor:pointer;
    user-select:none;
    line-height:1.2;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px;
    box-shadow:2px 2px 6px rgb(0 0 0 / .2);
  }
  #calibratorTab span.arrow {
    font-size:16px;
    line-height:16px;
  }
  #calibratorPanel {
    background:var(--panel);
    border:1px solid var(--line);
    border-left:none;
    border-top-right-radius:8px;
    border-bottom-right-radius:8px;
    min-width:180px;
    padding:12px;
    box-shadow:2px 2px 10px rgb(0 0 0 / .25);
    display:none;
  }
  #calibratorPanel h3 {
    margin:0 0 8px 0;
    font-size:13px;
    font-weight:600;
    color:var(--ink);
  }
  .calib-row {
    font-size:12px;
    margin-bottom:10px;
    display:grid;
    grid-template-columns:1fr auto;
    align-items:center;
    column-gap:6px;
  }
  .calib-row label {
    display:block;
    font-weight:500;
    color:var(--muted);
    grid-column:1 / span 2;
    margin-bottom:4px;
  }
  .calib-row input[type="range"] {
    width:100%;
  }
  .calib-row .numField {
    width:48px;
    font-size:12px;
    padding:2px 4px;
    border:1px solid var(--line);
    border-radius:4px;
    text-align:center;
    background:#fff;
    color:var(--ink);
  }
  #calibReadout {
    font-size:11px;
    line-height:1.4;
    background:#f6f8fa;
    border:1px solid var(--line);
    border-radius:4px;
    padding:6px;
    white-space:nowrap;
  }
  #calibReadout code {
    font-family:ui-monospace,SFMono-Regular,Consolas,"Liberation Mono",monospace;
    font-size:11px;
    background:none;
    padding:0;
  }

  /* === SIDEBAR CALIBRATION PANEL (full system) === */
  .tinyNote{
    font-size:12px;
    line-height:1.4;
    color:var(--muted);
    margin:0 0 8px;
  }
  .calGroup{
    border:1px solid var(--line);
    border-radius:6px;
    padding:8px;
    margin-bottom:10px;
    background:#f9fafc;
  }
  .calHeader{
    font-size:13px;
    font-weight:600;
    margin:0 0 6px;
    color:var(--ink);
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
  }
  .calRow{
    display:flex;
    align-items:center;
    gap:6px;
    margin-bottom:6px;
    flex-wrap:wrap;
  }
  .calRow label{
    min-width:40px;
    font-size:12px;
    color:var(--muted);
  }
  .calRow input[type="range"]{
    flex:1;
  }
  .calVal{
    font-size:12px;
    min-width:38px;
    text-align:right;
    color:var(--ink);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    font-variant-numeric:tabular-nums;
  }
  #calibrationExport{
    width:100%;
    min-height:120px;
    font-family:ui-monospace,SFMono-Regular,Consolas,"Liberation Mono",monospace;
    font-size:12px;
    border:1px solid var(--line);
    border-radius:6px;
    padding:6px;
    background:#f6f8fa;
    resize:vertical;
  }

  /* COPYRIGHT FOOTER */
  #pageFooter{
    text-align:center;
    font-size:11px;
    color:var(--muted);
    background:var(--panel);
    border-top:1px solid var(--line);
    padding:8px 0;
    position:fixed;
    bottom:0;
    left:0;
    right:0;
    z-index:5;
  }

  /* MOBILE */
  @media (max-width:768px){
    #layoutShell{
      flex-direction:column;
      height:auto;
      min-height:calc(100vh - 58px);
    }

    .panel-shell{
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:80%;
      max-width:80%;
      min-width:260px;
      box-shadow:0 30px 60px rgb(0 0 0 / .4);
      background:transparent;
      transition:transform .2s ease;
      z-index:10002;
    }

    #layoutShell.sidebar-open .panel-shell{
      transform:translateX(0);
    }
    #layoutShell.sidebar-collapsed .panel-shell{
      transform:translateX(-100%);
    }

    #controls{
      width:100%!important;
      max-width:100%!important;
      min-width:100%!important;
      border-radius:12px 0 0 12px;
    }
    #panelResizer{display:none;} /* no manual drag resize on narrow screens */

    #previewWrapper{
      order:2;
      flex:1;
    }
  }
</style>
</head>
<body>

<header>
  <h1>CAP Uniform Builder</h1>
  <div class="subtitle">C/Capt. Guiseppe Doran â€¢ CAPR 39-1 logic â€¢ live rack & badge validation</div>
</header>

<!-- HAMBURGER MENU BUTTON -->
<button id="hamburgerBtn" class="hamburgerBtn" aria-label="Menu">
  <span></span><span></span><span></span>
</button>

<!-- Floating rack-only calibrator -->
<div id="calibratorWrapper">
  <div id="calibratorTab">
    <span>RACK</span>
    <span class="arrow" id="calibratorArrow">â€º</span>
  </div>

  <div id="calibratorPanel">
    <h3>Ribbon Rack Cal</h3>

    <div class="calib-row">
      <label for="rackXRange">X Offset (left px)</label>
      <input type="range" id="rackXRange" min="150" max="400" step="1">
      <input type="number" id="rackXNumber" class="numField">
    </div>

    <div class="calib-row">
      <label for="rackYRange">Y Offset (top px)</label>
      <input type="range" id="rackYRange" min="150" max="320" step="1">
      <input type="number" id="rackYNumber" class="numField">
    </div>

    <div id="calibReadout">
      <div>Base X: <code id="readX"></code> px</div>
      <div>Base Y: <code id="readY"></code> px</div>
      <div>Ribbon WÃ—H: <code id="readSize"></code> px</div>
    </div>
  </div>
</div>

<!-- MAIN APP LAYOUT -->
<main id="layoutShell" class="sidebar-open">

  <!-- SIDEBAR (resizable wrapper) -->
  <div class="panel-shell" id="panelShell">
    <aside id="controls">
      <div class="controlsHeader">
        <div>
          <h2 class="controlsTitle">Uniform Builder Controls</h2>
          <div class="controlsSub">Member type governs auth; panel can resize.</div>
        </div>
      </div>

      <div class="controlsScrollArea">
        <!-- MEMBER TYPE -->
        <section class="panelBlock">
          <label class="fieldLabel">Member Type</label>
          <select id="memberSelect">
            <option value="cadet">Cadet</option>
            <option value="senior">Senior Member / Officer</option>
            <option value="senior_nco">Senior Member NCO</option>
          </select>
          <div class="hintText">This also hides Senior-Member-only ribbons if you're a cadet.</div>
        </section>

        <!-- GENDER -->
        <section class="panelBlock">
          <label class="fieldLabel">Gender / Cut</label>
          <select id="jacketSelect">
            <option value="male">Male Cut</option>
            <option value="female">Female Cut</option>
          </select>
          <div class="hintText">Swaps which base jacket image we render.</div>
        </section>

        <!-- UNIFORM SELECTOR -->
        <section class="panelBlock">
          <label class="fieldLabel">Uniform</label>
          <div id="uniformList" class="uniformList">

            <button class="uniformOption"
                    data-uniform-id="blues_a"
                    data-allowed-for="cadet,senior,senior_nco">
              <div class="uName">Blues: Class A</div>
              <div class="uDesc smallText">Service coat, ribbons</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="blues_b"
                    data-allowed-for="cadet,senior,senior_nco">
              <div class="uName">Blues: Class B</div>
              <div class="uDesc smallText">Shirt, ribbons</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="mess_dress"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Mess Dress</div>
              <div class="uDesc smallText">Mini medals / formal</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="semi_formal"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Semi-formal</div>
              <div class="uDesc smallText">Mini medals</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="aviator"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Aviator Shirt</div>
              <div class="uDesc smallText">Corporate white shirt</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="aviator_blazer"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Aviator + Blazer</div>
              <div class="uDesc smallText">Corporate coat style</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="corporate_field"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Corporate Field Uniform</div>
              <div class="uDesc smallText">Field / utility variant</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="abu"
                    data-allowed-for="cadet,senior,senior_nco">
              <div class="uName">ABU</div>
              <div class="uDesc smallText">Legacy camo / tapes</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="flight_suit"
                    data-allowed-for="cadet,senior,senior_nco">
              <div class="uName">Flight Suit</div>
              <div class="uDesc smallText">Flight / utility</div>
            </button>

            <button class="uniformOption"
                    data-uniform-id="polo"
                    data-allowed-for="senior,senior_nco">
              <div class="uName">Polo</div>
              <div class="uDesc smallText">Corporate polo / gray slacks</div>
            </button>
          </div>

          <div class="hintText">
            Grayed-out uniforms are not authorized for the selected member type.
          </div>
        </section>

        <!-- ASSET BASE -->
        <section class="panelBlock">
          <div class="row two">
            <div class="col">
              <label class="fieldLabel">Asset Base Path</label>
              <input id="assetBase" value="images" placeholder="images"/>
            </div>
            <div class="col">
              <label class="fieldLabel" style="visibility:hidden">Apply</label>
              <button id="applyJacket" class="ghost">Apply Jacket</button>
            </div>
          </div>
          <div class="hintText">Change if your image folder path changes.</div>
        </section>

        <!-- RIBBONS GRID / DEVICES -->
        <section class="panelBlock">
          <div class="subsection-header">
            <div>
              <div class="subsection-title">Ribbons / Devices</div>
              <div class="subsection-hint">
                Check to add. Choose a device for that ribbon.  
                Senior-Member-only ribbons are hidden for cadets.
              </div>
            </div>
            <button id="clearRibbons" class="ghost" style="font-size:11px;line-height:1;padding:4px 8px;border-radius:6px;">
              Clear
            </button>
          </div>

          <div class="ribbonGrid" id="ribbonGrid"></div>

          <label style="font-size:12px;color:var(--muted);display:block;margin-top:10px;">
            <input type="checkbox" id="toggleMini">
            Force Mini Medals (override)
          </label>

          <label style="font-size:12px;color:var(--muted);display:block;margin-top:6px;">
            <input type="checkbox" id="autoMini" checked>
            Auto-convert ribbons â†’ mini-medals on Mess/Semi-formal
          </label>

          <!-- Multi-apply device box -->
          <div id="deviceTool">
            <strong style="font-size:12px;">Ribbon Devices â€” Multi-Apply</strong>
            <div id="devicePicker"></div>
            <div class="row" style="margin-top:8px">
              <button id="deviceApplyModeBtn" type="button">Enable Apply Mode</button>
              <button id="deviceRemoveModeBtn" type="button" class="ghost">Enable Remove Mode</button>
              <button id="deviceClearSelectionBtn" type="button" class="ghost">Clear Selection</button>
            </div>
            <small style="color:#516079;display:block;margin-top:6px;font-size:11px;line-height:1.3;">
              Choose devices + quantities â†’ Enable Apply Mode â†’ click a ribbon (in preview) to add them.
              Use Remove Mode to clear devices from that ribbon.
            </small>
          </div>

          <div class="row two" style="margin-top:12px">
            <div class="col"><button id="toggleRibbonDrag" class="ghost">Enable Drag Mode</button></div>
            <div class="col"><button id="logRibbonCoords" class="ghost">Log Ribbon Coords</button></div>
          </div>
          <div class="hintText">
            Drag Mode lets you reposition ribbons on the jacket for calibration.  
            "Log Ribbon Coords" prints their exact left/top to console.
          </div>
        </section>

        <!-- BADGES -->
        <section class="panelBlock">
          <label class="fieldLabel">Badges</label>
          <div class="row two">
            <div class="col"><select id="badgeSelect"></select></div>
            <div class="col"><button id="addBadge">Add Badge</button></div>
          </div>
          <div class="row two" style="margin-top:6px">
            <div class="col"><select id="removeBadgeSelect"></select></div>
            <div class="col"><button id="removeBadge" class="ghost">Remove Badge</button></div>
          </div>
          <div class="hintText">
            Auto-placed per CAPR 39-1. Cadet-only / SM-only logic enforced. Max 5 total.
            Over-rack badges sit 25px above the top ribbon row, centered.
          </div>
        </section>

        <!-- PATCHES -->
        <section class="panelBlock" id="groupPatches">
          <label class="fieldLabel">Patches</label>
          <div class="row two">
            <div class="col"><select id="patchSelect"></select></div>
            <div class="col"><button id="addPatch">Add Patch</button></div>
          </div>
          <div class="row two" style="margin-top:6px">
            <div class="col"><select id="removePatchSelect"></select></div>
            <div class="col"><button id="removePatch" class="ghost">Remove Patch</button></div>
          </div>
          <div class="hintText">
            Field uniforms swap certain badges/ribbons into patch/tape equivalents automatically.
          </div>
        </section>

        <!-- RANK / NAME / DOWNLOAD -->
        <section class="panelBlock">
          <label class="fieldLabel">Rank Insignia & Output</label>
          <div class="row two">
            <div class="col"><select id="rankSelect"></select></div>
            <div class="col"><button id="addRank">Set Rank</button></div>
          </div>
          <div class="row two" style="margin-top:6px">
            <div class="col"><button id="addNameplate" class="ghost">Add Nameplate</button></div>
            <div class="col"><button id="downloadImage">Download PNG</button></div>
          </div>
          <div class="hintText">
            Download exports a high-res PNG of the preview.
          </div>
        </section>

        <!-- FULL CALIBRATION PANEL -->
        <section id="calibrationPanelSidebar" class="panelSection">
          <h2 style="margin-top:0;font-size:13px;font-weight:600;color:var(--ink);">
            Calibration (All Items)
          </h2>
          <p class="tinyNote">
            Live-adjust X/Y/rotations. Copy JSON below into constants once dialed.
          </p>

          <div id="calibrationControls"></div>

          <div style="margin-top:16px;">
            <label for="calibrationExport" class="tinyNote"
                   style="display:block;margin-bottom:4px;">
              Export current calibration:
            </label>
            <textarea id="calibrationExport"></textarea>
          </div>
        </section>

        <!-- COPYRIGHT -->
        <section class="panelBlock" style="text-align:center;font-size:10.5px;color:var(--muted);line-height:1.3;">
          <div id="sidebarCopyrightLine">
            Â© <span id="sidebarYear"></span> Civil Air Patrol Uniform Builder<br/>
            Developed by C/Capt. Guiseppe Doran
          </div>
        </section>

      </div>
    </aside>

    <!-- drag handle -->
    <div id="panelResizer" title="Drag to resize panel"></div>
  </div>

  <!-- PREVIEW AREA -->
  <section id="previewWrapper">
    <div id="previewArea">
      <div id="uniformCanvas"></div>
    </div>

    <div id="sideDisplay">
      <div id="epauletContainer"></div>
      <div id="coverContainer"></div>
    </div>
  </section>

  <!-- GLOBAL HOVER TOOLTIP -->
  <div id="tooltip" class="tooltipBubble" style="display:none;"></div>

</main>

<!-- Hidden assets root -->
<div class="layer" id="assets" style="display:none"></div>

<!-- COPYRIGHT FOOTER -->
<footer id="pageFooter">
  Â© <span id="footerYear"></span> Civil Air Patrol Uniform Builder â€“ Developed by C/Capt. Guiseppe Doran
</footer>

<script>
/* ===========================
   GLOBAL STATE
   =========================== */
const State = {
  member:'cadet',
  gender:'male',
  uniform:'blues_a',
  assetBase:'images',

  // ribbons now driven by ribbonGrid instead of addRibbon button:
  // [{id, devices:{devId:qty}}]
  ribbons:[],

  badges:[],
  patches:[],
  rank:null,

  deviceApplyMode:false,
  deviceRemoveMode:false,
  selectedDevices:{},

  ribbonDragMode:false,
  forceMini:false
};

let currentDrag = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

/* ===========================
   CALIBRATION STATE
   =========================== */
const calibrationData = {};

function applyCalibrationToElement(elementId){
  const entry = calibrationData[elementId];
  const el = document.getElementById(elementId);
  if(!el || !entry) return;

  el.style.position = "absolute";
  el.style.left = entry.x + "px";
  el.style.top = entry.y + "px";
  el.style.transformOrigin = "center center";
  el.style.transform = "rotate(" + entry.rotation + "deg)";
}

function registerCalibratable(elementId, displayName, initialX, initialY, initialRot=0){
  if(!calibrationData[elementId]){
    calibrationData[elementId] = {
      name: displayName,
      x: initialX,
      y: initialY,
      rotation: initialRot
    };
  }
  applyCalibrationToElement(elementId);
  rebuildCalibrationUI();
  exportCalibrationJSON();
}

function rebuildCalibrationUI(){
  const wrap = document.getElementById("calibrationControls");
  if(!wrap) return;
  wrap.innerHTML = "";

  Object.keys(calibrationData).forEach(elementId=>{
    const item = calibrationData[elementId];

    const group = document.createElement("div");
    group.className = "calGroup";

    const header = document.createElement("div");
    header.className = "calHeader";
    header.innerHTML = `
      <span>${item.name}</span>
      <span style="font-size:11px;color:var(--muted);">id: ${elementId}</span>
    `;
    group.appendChild(header);

    // X
    const rowX = document.createElement("div");
    rowX.className = "calRow";
    const labelX = document.createElement("label");
    labelX.textContent = "X";
    rowX.appendChild(labelX);

    const sliderX = document.createElement("input");
    sliderX.type = "range";
    sliderX.min = -200;
    sliderX.max = 400;
    sliderX.step = 1;
    sliderX.value = item.x;
    rowX.appendChild(sliderX);

    const valX = document.createElement("div");
    valX.className = "calVal";
    valX.textContent = item.x + "px";
    rowX.appendChild(valX);

    sliderX.addEventListener("input", ()=>{
      item.x = parseInt(sliderX.value,10);
      applyCalibrationToElement(elementId);
      valX.textContent = item.x + "px";
      exportCalibrationJSON();
    });

    group.appendChild(rowX);

    // Y
    const rowY = document.createElement("div");
    rowY.className = "calRow";
    const labelY = document.createElement("label");
    labelY.textContent = "Y";
    rowY.appendChild(labelY);

    const sliderY = document.createElement("input");
    sliderY.type = "range";
    sliderY.min = 0;
    sliderY.max = 600;
    sliderY.step = 1;
    sliderY.value = item.y;
    rowY.appendChild(sliderY);

    const valY = document.createElement("div");
    valY.className = "calVal";
    valY.textContent = item.y + "px";
    rowY.appendChild(valY);

    sliderY.addEventListener("input", ()=>{
      item.y = parseInt(sliderY.value,10);
      applyCalibrationToElement(elementId);
      valY.textContent = item.y + "px";
      exportCalibrationJSON();
    });

    group.appendChild(rowY);

    // ROT
    const rowR = document.createElement("div");
    rowR.className = "calRow";
    const labelR = document.createElement("label");
    labelR.textContent = "ROT";
    rowR.appendChild(labelR);

    const sliderR = document.createElement("input");
    sliderR.type = "range";
    sliderR.min = -30;
    sliderR.max = 30;
    sliderR.step = 0.5;
    sliderR.value = item.rotation;
    rowR.appendChild(sliderR);

    const valR = document.createElement("div");
    valR.className = "calVal";
    valR.textContent = item.rotation + "Â°";
    rowR.appendChild(valR);

    sliderR.addEventListener("input", ()=>{
      item.rotation = parseFloat(sliderR.value);
      applyCalibrationToElement(elementId);
      valR.textContent = item.rotation + "Â°";
      exportCalibrationJSON();
    });

    group.appendChild(rowR);

    wrap.appendChild(group);
  });
}

function exportCalibrationJSON(){
  const out = document.getElementById("calibrationExport");
  if(!out) return;
  const slim = {};
  Object.keys(calibrationData).forEach(id=>{
    const {x,y,rotation} = calibrationData[id];
    slim[id] = {x,y,rotation};
  });
  out.value = JSON.stringify(slim, null, 2);
}

/* ===========================
   CALIBRATION CONSTANTS
   =========================== */
let rackBaseX = 259;
let rackBaseY = 206;

const RIBBON_WIDTH  = 23;
const RIBBON_HEIGHT = 7.2;
const RIBBON_GAP_X  = 0;
/* NOTE: you said "there is no y offset between ribbons,
   they should be right up against eachother" so vertical stack uses
   ribbon height directly. RIBBON_GAP_Y is informational. */
const RIBBON_GAP_Y  = 2; 

function getRackOrigin(){
  return { x:rackBaseX, y:rackBaseY };
}

/* ===========================
   DOM SHORTCUTS
   =========================== */
const $ = s => document.querySelector(s);
const by = id => document.getElementById(id);

const layoutShell      = by('layoutShell');
const hamburgerBtn     = by('hamburgerBtn');
const panelShell       = by('panelShell');
const panelResizer     = by('panelResizer');
const controlsPanel    = by('controls');

const uniformCanvas    = by('uniformCanvas');
const assetsContainer  = by('assets');
const uniformListEl    = by('uniformList');
const memberSelect     = by('memberSelect');
const jacketSelect     = by('jacketSelect');
const assetBaseInput   = by('assetBase');

/* ===========================
   YEAR AUTOFILL
   =========================== */
(function setYears(){
  const y = new Date().getFullYear();
  const sidebarYear = by('sidebarYear');
  const footerYear  = by('footerYear');
  if(sidebarYear) sidebarYear.textContent = y;
  if(footerYear)  footerYear.textContent  = y;
})();

/* ===========================
   ASSET PATH HELPER
   =========================== */
function ASSET(p){
  const b=(State.assetBase||'images').replace(/\/$/,'');
  return `${b}/${p}`;
}

/* ===========================
   UNIFORMS
   =========================== */
function isFieldUniform(u){
  return u==='abu' || u==='flight_suit' || u==='corporate_field';
}

const UNIFORMS = {
  blues_a:{male:'base/jacket_male.png',         female:'base/jacket_female.png',         ribbons:true,  mini:false},
  blues_b:{male:'base/blues_class_b_male.png',  female:'base/blues_class_b_female.png',  ribbons:true,  mini:false},
  mess_dress:{male:'base/mess_dress_male.png',  female:'base/mess_dress_female.png',     ribbons:false, mini:true},
  semi_formal:{male:'base/semi_male.png',       female:'base/semi_female.png',           ribbons:false, mini:true},
  aviator:{male:'base/aviator_shirt_male.png',  female:'base/aviator_shirt_female.png',  ribbons:true,  mini:false},
  aviator_blazer:{male:'base/aviator_blazer_male.png',female:'base/aviator_blazer_female.png', ribbons:true,mini:false},
  corporate_field:{male:'base/corporate_field_male.png',female:'base/corporate_field_female.png', ribbons:true, mini:false},
  abu:{male:'base/ABU_male.png',                female:'base/ABU_female.png',            ribbons:false, mini:false},
  flight_suit:{male:'base/flight_suit_male.png',female:'base/flight_suit_female.png',    ribbons:false, mini:false},
  polo:{male:'base/polo_male.png',              female:'base/polo_female.png',           ribbons:false, mini:false}
};

const UI_AUTHZ = {
  blues_a:{ showRibbons:true, showBadges:true,  showPatches:false },
  blues_b:{ showRibbons:true, showBadges:true,  showPatches:false },
  aviator:{ showRibbons:true, showBadges:true,  showPatches:false },
  aviator_blazer:{ showRibbons:true, showBadges:true, showPatches:false },
  corporate_field:{ showRibbons:true, showBadges:false, showPatches:true },
  mess_dress:{ showRibbons:false, showBadges:true,  showPatches:false },
  semi_formal:{ showRibbons:false, showBadges:true, showPatches:false },
  abu:{ showRibbons:false, showBadges:false, showPatches:true },
  flight_suit:{ showRibbons:false, showBadges:false, showPatches:true },
  polo:{ showRibbons:false, showBadges:false, showPatches:false }
};

/* ===========================
   RIBBONS & DEVICES DATA
   =========================== */

/* Senior Member only ribbons list */
const SM_ONLY_RIBBONS = [
  "Gill Robb Wilson Award Ribbon",
  "Paul E Garber Award Ribbon",
  "Grover Loening Aerospace Award Ribbon",
  "Leadership Award Ribbon",
  "CAP Membership Award Ribbon",
  "A Scott Crossfield Award Ribbon",
  "Brigadier General Charles E. Yeager Aerospace Education Achievement Award Ribbon",
  "Command Service Ribbon",
  "Cadet Orientation Pilot Ribbon",
  "Senior Recruiter Ribbon",
  "World War 2 Service Ribbon"
];

/*
Each ribbon object in RIBBONS:
id          unique key (used internally / matches preloaded image ids if possible)
name        display label
img         relative path in images/ribbons
smOnly      true if only for seniors
precedence  1 = highest
devices     array of {value,label} device options for per-ribbon dropdown
*/
const RIBBONS = [
  {
    id:"spaatz_award",
    name:"General Carl A. Spaatz Award Ribbon",
    img:"ribbons/spaatz_award.png",
    smOnly:false,
    precedence:1,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"earhart_award",
    name:"Amelia Earhart Award Ribbon",
    img:"ribbons/earhart_award.png",
    smOnly:false,
    precedence:2,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"mitchell_award",
    name:"General Billy Mitchell Award Ribbon",
    img:"ribbons/mitchell_award.png",
    smOnly:false,
    precedence:3,
    devices:[{value:"",label:"None"}]
  },

  /* SM-only set you gave */
  {
    id:"gill_robb_wilson",
    name:"Gill Robb Wilson Award Ribbon",
    img:"ribbons/gill_robb_wilson.png",
    smOnly:true,
    precedence:10,
    devices:[
      {value:"",label:"None"},
      {value:"bronze_star",label:"Bronze Star"},
      {value:"silver_star",label:"Silver Star"},
      {value:"gold_star",label:"Gold Star"}
    ]
  },
  {
    id:"paul_garber",
    name:"Paul E Garber Award Ribbon",
    img:"ribbons/paul_garber.png",
    smOnly:true,
    precedence:11,
    devices:[
      {value:"",label:"None"},
      {value:"bronze_star",label:"Bronze Star"},
      {value:"silver_star",label:"Silver Star"},
      {value:"gold_star",label:"Gold Star"}
    ]
  },
  {
    id:"grover_loening",
    name:"Grover Loening Aerospace Award Ribbon",
    img:"ribbons/grover_loening.png",
    smOnly:true,
    precedence:12,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"leadership_award",
    name:"Leadership Award Ribbon",
    img:"ribbons/leadership_award.png",
    smOnly:true,
    precedence:13,
    devices:[
      {value:"",label:"None"},
      {value:"bronze_star",label:"Bronze Star"},
      {value:"silver_star",label:"Silver Star"}
    ]
  },
  {
    id:"membership_award",
    name:"CAP Membership Award Ribbon",
    img:"ribbons/membership_award.png",
    smOnly:true,
    precedence:14,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"crossfield",
    name:"A Scott Crossfield Award Ribbon",
    img:"ribbons/crossfield.png",
    smOnly:true,
    precedence:15,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"yeager",
    name:"Brigadier General Charles E. Yeager Aerospace Education Achievement Award Ribbon",
    img:"ribbons/yeager.png",
    smOnly:true,
    precedence:16,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"command_service",
    name:"Command Service Ribbon",
    img:"ribbons/command_service.png",
    smOnly:true,
    precedence:17,
    devices:[
      {value:"",label:"None"},
      {value:"bronze_star",label:"Bronze Star"},
      {value:"silver_star",label:"Silver Star"},
      {value:"gold_star",label:"Gold Star"},
      {value:"gold_star_2",label:"Two Gold Stars"}
    ]
  },
  {
    id:"o_ride_pilot",
    name:"Cadet Orientation Pilot Ribbon",
    img:"ribbons/orientation_pilot.png",
    smOnly:true,
    precedence:18,
    devices:[
      {value:"",label:"None"},
      {value:"bronze_clasp",label:"Bronze Clasp"}
    ]
  },
  {
    id:"senior_recruiter",
    name:"Senior Recruiter Ribbon",
    img:"ribbons/senior_recruiter.png",
    smOnly:true,
    precedence:19,
    devices:[{value:"",label:"None"}]
  },
  {
    id:"ww2_service",
    name:"World War 2 Service Ribbon",
    img:"ribbons/ww2_service.png",
    smOnly:true,
    precedence:20,
    devices:[{value:"",label:"None"}]
  }
];

/*
miniMedalImages maps ribbon id -> path for its miniature medal.
You already had this data in your previous file; keeping the same structure.
*/
const miniMedalImages = {
  /* sample mapping using your earlier keys;
     merge the rest of your existing miniMedalImages here */
  "spaatz_award":"images/medals/carl_a_spaatz.png",
  "earhart_award":"images/medals/amelia_earhart.png",
  "mitchell_award":"images/medals/billy_mitchell.png",
  "gill_robb_wilson":"images/medals/gill_robb_wilson.png",
  "paul_garber":"images/medals/paul_e_garber.png",
  "grover_loening":"images/medals/grover_loening.png",
  "leadership_award":"images/medals/leadership.png",
  "membership_award":"images/medals/membership.png",
  "command_service":"images/medals/command_service.png",
  "ww2_service":"images/medals/world_war_2_service.png",
  "senior_recruiter":"images/medals/recruiting.png",
  "yeager":"images/medals/charles_yaeger.png",
  "crossfield":"images/medals/a_scott_crossfield.png",
  "o_ride_pilot":"images/medals/orientation_pilot.png"
};

/* per-device metadata */
const deviceList = [
  '1_Bronze_Star_Device',
  '1_Silver_Star_Device'
];
const deviceMeta = {
  '1_Bronze_Star_Device': { label:'Bronze Star', src:'devices/1_Bronze_Star_Device.webp', w:10, h:10, weight:1 },
  '1_Silver_Star_Device': { label:'Silver Star', src:'devices/1_Silver_Star_Device.webp', w:10, h:10, weight:2 }
};

/* ===========================
   BADGES / PATCHES / RANKS DATA
   =========================== */
const badgeList = [
  'AirCrew1_DB3F0FCC3650F','BalloonPilot1_442D89C94185B','CAPMasterPilot1_621A0E2ED15DA','CAPPilot1_FA9D33EA587D8','CAPSeniorPilot1_D9725AE959752','GliderPilot1_7BFB287379918','MasterAirCrew1_72AC4CAE7A310','MasterObserver1_1B88D5071FD5C','SeniorAirCrew1_B289BAE6E515C','SeniorObserver1_0E35802A29801',
  'buddist_chaplin','christian_chaplin','communications_technician_badge','cyber_badges','emergency_services_badge','emt_basic_badge','emt_intermediate','emt_paramedic','ground_team_basic_badge','historian_technicianIbadge','information_technology_technician_badge','jewish_chaplin','legal_officer','master_ground_team_badge','medical_officer','model_rocketry_badge','muslim_chaplin','nra_marksman_badge','nurse_officer','observer_badge','pre_solo_badge','senior_ground_team_badge','solo_badge','stem_badges'
];

const allowedCadetBadges = new Set([
  'solo_badge','pre_solo_badge','ground_team_basic_badge','senior_ground_team_badge','master_ground_team_badge','emt_basic_badge','emt_intermediate','emt_paramedic','aerospace','model_rocketry_badge','communications_technician_badge','information_technology_technician_badge','cyber_badges','stem_badges','cadetadvisory','cd','nra_marksman_badge','AirCrew1_DB3F0FCC3650F','BalloonPilot1_442D89C94185B','CAPMasterPilot1_621A0E2ED15DA','CAPPilot1_FA9D33EA587D8','CAPSeniorPilot1_D9725AE959752','GliderPilot1_7BFB287379918','MasterAirCrew1_72AC4CAE7A310','SeniorAirCrew1_B289BAE6E515C','SeniorObserver1_0E35802A29801','MasterObserver1_1B88D5071FD5C','observer_badge','emergency_services_badge','historian_technicianIbadge'
]);

const exclusiveBadges = [
  ['emt_basic_badge','ground_team_basic_badge'],
  ['emt_intermediate','senior_ground_team_badge'],
  ['emt_paramedic','master_ground_team_badge']
];

const badgeLocations = {
  'AirCrew1_DB3F0FCC3650F':'OLP','BalloonPilot1_442D89C94185B':'OLP','CAPMasterPilot1_621A0E2ED15DA':'OLP','CAPPilot1_FA9D33EA587D8':'OLP','CAPSeniorPilot1_D9725AE959752':'OLP','GliderPilot1_7BFB287379918':'OLP','MasterAirCrew1_72AC4CAE7A310':'OLP',
  'SeniorAirCrew1_B289BAE6E515C':'OLP','pre_solo_badge':'OLP','solo_badge':'OLP',

  'cyber_badges':'LP','stem_badges':'LP','communications_technician_badge':'LP','information_technology_technician_badge':'LP','MasterObserver1_1B88D5071FD5C':'LP','SeniorObserver1_0E35802A29801':'LP','observer_badge':'LP','historian_technicianIbadge':'LP','model_rocketry_badge':'LP',

  'nra_marksman_badge':'LRP',

  'ground_team_basic_badge':'OLPU','senior_ground_team_badge':'OLPU','master_ground_team_badge':'OLPU','emergency_services_badge':'OLPU','emt_basic_badge':'OLPU','emt_intermediate':'OLPU','emt_paramedic':'OLPU',

  'buddist_chaplin':'ORP','christian_chaplin':'ORP','jewish_chaplin':'ORP','legal_officer':'ORP','medical_officer':'ORP','nurse_officer':'ORP','muslim_chaplin':'ORP'
};

const customBadgeSizes = {
  'AirCrew1_DB3F0FCC3650F':{width:60,height:25},'BalloonPilot1_442D89C94185B':{width:60,height:25},'CAPMasterPilot1_621A0E2ED15DA':{width:60,height:25},'CAPPilot1_FA9D33EA587D8':{width:60,height:25},'CAPSeniorPilot1_D9725AE959752':{width:60,height:25},'GliderPilot1_7BFB287379918':{width:60,height:25},'MasterAirCrew1_72AC4CAE7A310':{width:60,height:25},'MasterObserver1_1B88D5071FD5C':{width:60,height:25},'SeniorAirCrew1_B289BAE6E515C':{width:60,height:25},'SeniorObserver1_0E35802A29801':{width:60,height:25},
  'buddist_chaplin':{width:60,height:60},'christian_chaplin':{width:60,height:60},'communications_technician_badge':{width:60,height:60},
  'cyber_badges':{width:60,height:25},'emergency_services_badge':{width:60,height:60},'emt_basic_badge':{width:60,height:60},
  'emt_intermediate':{width:60,height:60},'emt_paramedic':{width:60,height:60},'ground_team_basic_badge':{width:25,height:20},
  'historian_technicianIbadge':{width:60,height:60},'information_technology_technician_badge':{width:60,height:60},
  'jewish_chaplin':{width:60,height:60},'legal_officer':{width:60,height:25},'master_ground_team_badge':{width:25,height:20},
  'medical_officer':{width:60,height:60},'model_rocketry_badge':{width:7,height:28.125},'muslim_chaplin':{width:60,height:60},
  'nra_marksman_badge':{width:40,height:60},'nurse_officer':{width:60,height:60},'observer_badge':{width:60,height:25},
  'pre_solo_badge':{width:60,height:25},'senior_ground_team_badge':{width:25,height:20},'solo_badge':{width:60,height:25},'stem_badges':{width:60,height:25}
};

const patchList = [
  'us_flag_patch','command_patch','wing_patch','unit_patch','aerospace_education_patch','communications_patch','orientation_pilot_patch'
];

const PATCH_META = {
  'us_flag_patch':{slotHint:'R_SHOULDER', w:60,h:40, img:'patches/us_flag_patch.png'},
  'command_patch':{slotHint:'L_SHOULDER', w:70,h:70, img:'patches/command_patch.png'},
  'wing_patch':{slotHint:'L_SHOULDER', w:60,h:60, img:'patches/wing_patch.png'},
  'unit_patch':{slotHint:'R_SHOULDER', w:60,h:60, img:'patches/unit_patch.png'},
  'aerospace_education_patch':{slotHint:'CHEST_LEFT', w:60,h:60, img:'patches/aerospace_education_patch.png'},
  'communications_patch':{slotHint:'CHEST_RIGHT', w:60,h:60, img:'patches/communications_patch.png'},
  'orientation_pilot_patch':{slotHint:'CHEST_LEFT', w:60,h:60, img:'patches/orientation_pilot_patch.png'}
};

const ALTERNATES = {
  badgeToPatch: { 'communications_technician_badge':'communications_patch' },
  patchToBadge: { 'communications_patch':'communications_technician_badge' },
  ribbonToPatch:{ 'o_ride_pilot':'orientation_pilot_patch' },
  patchToRibbon:{ 'orientation_pilot_patch':'o_ride_pilot' }
};

const rankList = [
  'C/AB','C/Amn','C/A1C','C/SrA','C/SSgt','C/TSgt','C/MSgt','C/SMSgt','C/CMSgt',
  'C/2d Lt','C/1st Lt','C/Capt','C/Maj','C/Lt Col','C/Col'
];
const officerRanks = new Set(['C/2d Lt','C/1st Lt','C/Capt','C/Maj','C/Lt Col','C/Col']);

/* ===========================
   HELPERS / PRELOAD
   =========================== */
function optionize(sel,list){
  sel.innerHTML='';
  list.forEach(v=>{
    const o=document.createElement('option');
    o.value=v;
    o.textContent=v.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    sel.appendChild(o);
  });
}

function populateBadgesRemove(){
  const sel=by('removeBadgeSelect'); if(!sel) return;
  sel.innerHTML='';
  State.badges.forEach(id=>{
    const o=document.createElement('option');
    o.value=id;
    o.textContent=id.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    sel.appendChild(o);
  });
}
function populatePatchesRemove(){
  const sel=by('removePatchSelect'); if(!sel) return;
  sel.innerHTML='';
  State.patches.forEach(id=>{
    const o=document.createElement('option');
    o.value=id;
    o.textContent=id.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    sel.appendChild(o);
  });
}

function preloadSimple(prefix,list,folder,ext=".png"){
  list.forEach(id=>{
    const img=document.createElement('img');
    img.id = `${prefix}-${id}`;
    img.src = ASSET(`${folder}/${id}${ext}`);
    img.style.display='none';
    img.loading='eager';
    img.decoding='sync';
    img.onerror=()=>{};
    assetsContainer.appendChild(img);
  });
}

function preloadWithResolver(prefix,list,resolver){
  list.forEach(id=>{
    const src = resolver(id);
    const img=document.createElement('img');
    img.id = `${prefix}-${id}`;
    img.src = ASSET(src);
    img.style.display='none';
    img.loading='eager';
    img.decoding='sync';
    img.onerror=()=>{};
    assetsContainer.appendChild(img);
  });
}

/* Build selects that still exist (badges, patches, rank) */
optionize(by('badgeSelect'), badgeList);
optionize(by('patchSelect'), patchList);
optionize(by('rankSelect'), rankList);

/* Preload assets */
preloadSimple('ranks', rankList, 'ranks', '.png');
preloadSimple('badges', badgeList, 'badges', '.png');
Object.entries(PATCH_META).forEach(([id,m])=>{
  const img=document.createElement('img');
  img.id=`patch-${id}`;
  img.src=ASSET(m.img);
  img.style.display='none';
  assetsContainer.appendChild(img);
});

/* Also preload ribbon images & device images for renderRack() */
preloadWithResolver('ribbons', RIBBONS.map(r=>r.id), id=>{
  const rb = RIBBONS.find(x=>x.id===id);
  return rb ? rb.img : `ribbons/${id}.png`;
});
preloadWithResolver('devices', deviceList, id => deviceMeta[id].src);

/* ===========================
   SIDEBAR TOGGLE
   =========================== */
layoutShell.classList.add('sidebar-open'); // default

hamburgerBtn.addEventListener('click', ()=>{
  if(layoutShell.classList.contains('sidebar-open')){
    layoutShell.classList.remove('sidebar-open');
    layoutShell.classList.add('sidebar-collapsed');
  }else{
    layoutShell.classList.remove('sidebar-collapsed');
    layoutShell.classList.add('sidebar-open');
  }
});

/* ===========================
   PANEL RESIZER DRAG LOGIC
   =========================== */
(function initPanelResizer(){
  let isDragging = false;
  let startX = 0;
  let startWidth = 0;

  panelResizer.addEventListener('mousedown',(e)=>{
    // only allow on desktop layout (panelResizer hidden on <768px)
    if(window.matchMedia("(max-width:768px)").matches) return;
    isDragging = true;
    startX = e.clientX;
    startWidth = controlsPanel.getBoundingClientRect().width;
    document.body.style.userSelect = "none";
  });

  window.addEventListener('mousemove',(e)=>{
    if(!isDragging)return;
    let newW = startWidth + (e.clientX - startX);
    if(newW < 260) newW = 260;
    if(newW > 480) newW = 480;
    controlsPanel.style.width = newW+"px";
  });

  window.addEventListener('mouseup',()=>{
    if(isDragging){
      isDragging=false;
      document.body.style.userSelect = "";
    }
  });
})();

/* ===========================
   TOOLTIP HOVER
   =========================== */
const tooltipEl = by('tooltip');

document.addEventListener('mouseover', e => {
  const t=e.target;
  if(t && t.dataset && t.dataset.tooltipTitle){
    const title=t.dataset.tooltipTitle||'';
    const reg  =t.dataset.tooltipReg||'';
    const why  =t.dataset.tooltipWhy||'';

    tooltipEl.innerHTML = `
      <strong>${title}</strong>
      ${reg ? `<div>${reg}</div>`:''}
      ${why ? `<div><em>${why}</em></div>`:''}
    `;
    tooltipEl.style.display='block';
  }
});
document.addEventListener('mousemove', e => {
  if(tooltipEl.style.display==='block'){
    tooltipEl.style.left = (e.clientX+14)+'px';
    tooltipEl.style.top  = (e.clientY+14)+'px';
  }
});
document.addEventListener('mouseout', e => {
  const t=e.target;
  if(t && t.dataset && t.dataset.tooltipTitle){
    tooltipEl.style.display='none';
  }
});

/* ===========================
   JACKET BASE RENDER
   =========================== */
function clearLayers(cls){
  const sel = cls?`.layer.${cls}`:'.layer';
  uniformCanvas.querySelectorAll(sel).forEach(n=>n.remove());
}

function applyJacket(){
  clearLayers('jacket');
  const base = UNIFORMS[State.uniform][State.gender];
  const img=document.createElement('img');
  img.className='layer jacket';
  img.src=ASSET(base);
  img.style.top='0px';
  img.style.left='0px';
  img.style.width='100%';
  img.style.height='100%';
  img.style.display='block';
  img.dataset.tooltipTitle = State.uniform.replace(/_/g,' ').toUpperCase();
  img.dataset.tooltipReg   = "Base uniform image";
  img.dataset.tooltipWhy   = "Selected uniform template for preview / alignment.";
  img.id = "jacketBaseImage";
  uniformCanvas.appendChild(img);
}

/* ===========================
   RIBBON / MEDAL RENDER LOGIC
   =========================== */
function sortRibbonsByPrecedence(){
  // State.ribbons is [{id,devices:{...}}]
  // Join info from RIBBONS to sort
  const arr = State.ribbons.map(r=>{
    const meta = RIBBONS.find(x=>x.id===r.id);
    return {...r, precedence: meta?meta.precedence:9999};
  });
  arr.sort((a,b)=>a.precedence-b.precedence);
  return arr;
}

function getTopRibbonY(){
  const layers=[...uniformCanvas.querySelectorAll('.layer.ribbonTile,.layer.ribbonMini')];
  if(!layers.length) {
    // fallback "where ribbons would be"
    return rackBaseY + 150;
  }
  return Math.min(...layers.map(l=>parseFloat(l.style.top)||0));
}

function ensureRibbonObj(id){
  let r=State.ribbons.find(x=>x.id===id);
  if(!r){
    r={id,devices:{}};
    State.ribbons.push(r);
  }
  if(!r.devices) r.devices={};
  return r;
}

function drawDevicesOnRibbon(rid,leftPx,topPx,w,h){
  const r=ensureRibbonObj(rid);
  const flat=[];
  for(const [devId,count] of Object.entries(r.devices||{})){
    const meta=deviceMeta[devId];
    if(!meta) continue;
    for(let i=0;i<count;i++){ flat.push({id:devId,...meta}); }
  }
  if(!flat.length) return;

  flat.sort((a,b)=>(b.weight-a.weight)|| (a.label||a.id).localeCompare(b.label||b.id));
  const gap=3;
  const totalW=flat.reduce((s,d,i)=>s+d.w+(i>0?gap:0),0);
  let x=Math.round(leftPx+(w-totalW)/2);
  const y=Math.round(topPx+(h-10)/2)-1;

  flat.forEach(d=>{
    const im=document.createElement('img');
    im.className='layer ribbonDevice';
    im.dataset.parentRid = rid;
    im.src=ASSET(d.src);
    im.alt=d.label||d.id;
    im.style.display='block';
    im.style.left=`${x}px`;
    im.style.top =`${y}px`;
    im.style.width =`${d.w}px`;
    im.style.height=`${d.h}px`;
    im.onerror=()=>{ im.remove(); };
    im.dataset.tooltipTitle = d.label||d.id;
    im.dataset.tooltipReg   = "Ribbon device";
    im.dataset.tooltipWhy   = "Represents additional awards/credit per CAPR 39-3.";
    uniformCanvas.appendChild(im);
    x+=d.w+gap;
  });
}

function onRibbonTileClick(rid){
  if(State.ribbonDragMode) return;
  if(State.deviceRemoveMode){
    const r=ensureRibbonObj(rid);
    r.devices={};
    renderRack();
    return;
  }
  if(!State.deviceApplyMode)return;
  const r=ensureRibbonObj(rid);
  for(const [devId,qty] of Object.entries(State.selectedDevices)){
    r.devices[devId]=(r.devices[devId]||0)+qty;
  }
  renderRack();
}

function initRibbonDragHandlers(tileEl){
  tileEl.addEventListener('mousedown', e => {
    if(!State.ribbonDragMode) return;
    currentDrag = tileEl;
    currentDrag.classList.add('dragging');
    const startLeft = parseFloat(currentDrag.style.left) || 0;
    const startTop  = parseFloat(currentDrag.style.top)  || 0;
    dragOffsetX = e.clientX - startLeft;
    dragOffsetY = e.clientY - startTop;
    e.preventDefault();
  });
}

function syncDevicesToRibbon(ribbonTileEl){
  const rid = ribbonTileEl.dataset.rid;
  if(!rid) return;
  const baseLeft = parseFloat(ribbonTileEl.style.left) || 0;
  const baseTop  = parseFloat(ribbonTileEl.style.top)  || 0;
  const w = parseFloat(ribbonTileEl.style.width)  || RIBBON_WIDTH;
  const h = parseFloat(ribbonTileEl.style.height) || RIBBON_HEIGHT;

  const r = State.ribbons.find(x => x.id===rid);
  if(!r || !r.devices) return;

  const flat=[];
  for(const [devId,count] of Object.entries(r.devices)){
    const meta=deviceMeta[devId];
    if(!meta) continue;
    for(let i=0;i<count;i++){ flat.push({id:devId,...meta}); }
  }
  flat.sort((a,b)=>(b.weight-a.weight)|| (a.label||a.id).localeCompare(b.label||b.id));

  const gap=3;
  const totalW=flat.reduce((s,d,i)=>s+d.w+(i>0?gap:0),0);
  let x=Math.round(baseLeft+(w-totalW)/2);
  const y=Math.round(baseTop+(h-10)/2)-1;

  const devEls=[...uniformCanvas.querySelectorAll('.ribbonDevice')].filter(el=>el.dataset.parentRid===rid);

  devEls.forEach((el,idx)=>{
    const dv=flat[idx];
    if(!dv) return;
    el.style.left = x+'px';
    el.style.top  = y+'px';
    x+=dv.w+gap;
  });
}

/* global drag move/up handlers */
document.addEventListener('mousemove', e => {
  if(!currentDrag || !State.ribbonDragMode) return;
  let newLeft = e.clientX - dragOffsetX;
  let newTop  = e.clientY - dragOffsetY;

  const maxX = 450 - (parseFloat(currentDrag.style.width)  || RIBBON_WIDTH);
  const maxY = 600 - (parseFloat(currentDrag.style.height) || RIBBON_HEIGHT);
  if(newLeft < 0) newLeft = 0;
  if(newTop  < 0) newTop  = 0;
  if(newLeft > maxX) newLeft = maxX;
  if(newTop  > maxY) newTop  = maxY;

  currentDrag.style.left = newLeft + 'px';
  currentDrag.style.top  = newTop  + 'px';

  syncDevicesToRibbon(currentDrag);

  const rid = currentDrag.dataset.rid;
  if(rid){
    const elId = "ribbonRack";
    rackBaseX = newLeft;
    rackBaseY = newTop;

    if(calibrationData[elId]){
      calibrationData[elId].x = rackBaseX;
      calibrationData[elId].y = rackBaseY;
      applyCalibrationToElement(elId);
      exportCalibrationJSON();
      rebuildCalibrationUI();
    }
  }
});
document.addEventListener('mouseup', () => {
  if(currentDrag){
    currentDrag.classList.remove('dragging');
    currentDrag = null;
  }
});

/*
renderRack():
- builds ribbon rows with your precedence rules
- no vertical gap (rows touch)
- bottom row locked at BOTTOM_ROW_Y
- top row is highest-precedence row
- after 9 ribbons you said you want offset logic (2-wide rows, etc.). You can extend here.
- also handles mini medals.
*/
function renderRack(){
  [...uniformCanvas.querySelectorAll('.layer.ribbonTile,.layer.ribbonMini,.layer.ribbonDevice')].forEach(n=>n.remove());

  const baseCfg = UNIFORMS[State.uniform];
  const uniformPrefersMini   = baseCfg.mini;
  const uniformAllowsRibbons = baseCfg.ribbons;
  const autoMini   = by('autoMini').checked;
  const manualMini = State.forceMini;
  const useMini = (uniformPrefersMini && autoMini) || manualMini;

  const ordered = sortRibbonsByPrecedence();
  if(!ordered.length){
    ensureRackCalibrationElement();
    return;
  }

  // Shared anchors from your logic
  const BOTTOM_ROW_Y   = 206;
  const RACK_CENTER_X  = 293.5;

  function rowLeftPositions(count, itemW){
    const totalWidth = count * itemW;
    const rowLeftBase = RACK_CENTER_X - totalWidth/2;
    const arr=[];
    for(let i=0;i<count;i++){
      arr.push(rowLeftBase + i*itemW);
    }
    return arr;
  }

  // ----- RIBBONS MODE -----
  if(!useMini && uniformAllowsRibbons){
    // bottom row = lowest precedence, 3 per row
    const lowestFirst = [...ordered].reverse(); // lowest precedence first
    const rowsBottomFirst = [];
    for(let i=0;i<lowestFirst.length;i+=3){
      rowsBottomFirst.push(lowestFirst.slice(i,i+3));
    }
    const rowsTopFirst = [...rowsBottomFirst].reverse();
    const totalRows = rowsTopFirst.length;

    rowsTopFirst.forEach((row,topIndex)=>{
      const indexFromBottom = (totalRows - 1 - topIndex);

      // "no y offset between ribbons" -> each row sits directly above the one below using ribbon height
      const rowTopPx = BOTTOM_ROW_Y - indexFromBottom * RIBBON_HEIGHT;

      // reverse so highest precedence is leftmost in its row
      const rowSortedForDisplay = [...row].reverse();

      const leftPositions = rowLeftPositions(rowSortedForDisplay.length, RIBBON_WIDTH);

      rowSortedForDisplay.forEach((ribbonObj,i)=>{
        const rid = ribbonObj.id;
        const imgEl=by(`ribbons-${rid}`);
        if(!imgEl) return;

        const tile=imgEl.cloneNode();
        tile.className='layer ribbonTile';
        tile.style.display='block';

        const leftPx = leftPositions[i];
        const topPx  = rowTopPx;

        tile.style.left   = `${leftPx}px`;
        tile.style.top    = `${topPx}px`;
        tile.style.width  = `${RIBBON_WIDTH}px`;
        tile.style.height = `${RIBBON_HEIGHT}px`;

        tile.dataset.rid=rid;
        tile.style.pointerEvents='auto';
        tile.onclick=()=>onRibbonTileClick(rid);

        tile.dataset.tooltipTitle = rid.replace(/_/g,' ').toUpperCase();
        tile.dataset.tooltipReg   = "CAPR 39-3 precedence applies";
        tile.dataset.tooltipWhy   = "Highest awards sit top row, leftward.";

        initRibbonDragHandlers(tile);

        uniformCanvas.appendChild(tile);

        drawDevicesOnRibbon(rid,leftPx,topPx,RIBBON_WIDTH,RIBBON_HEIGHT);
      });
    });

    ensureRackCalibrationElement();
    return;
  }

  // ----- MINI MEDALS MODE -----
  const MINI_W = 20;
  const MINI_H = 28;
  const MEDAL_PER_ROW = 5;
  const PAD = 6;

  const medalItems = [];
  for(const r of ordered){
    const medalPath = miniMedalImages[r.id];
    if(medalPath){
      medalItems.push({ id:r.id, path:medalPath });
    }
  }
  if(!medalItems.length){
    ensureRackCalibrationElement();
    return;
  }

  const lowestFirstMedals = [...medalItems].reverse();
  const medalRowsBottomFirst = [];
  for(let i=0;i<lowestFirstMedals.length;i+=MEDAL_PER_ROW){
    medalRowsBottomFirst.push(lowestFirstMedals.slice(i,i+MEDAL_PER_ROW));
  }
  const medalRowsTopFirst = [...medalRowsBottomFirst].reverse();
  const totalMedalRows = medalRowsTopFirst.length;

  const BOTTOM_ROW_Y_MEDALS = BOTTOM_ROW_Y + 20;

  function medalRowLeftPositions(count){
    const totalWidth = count * MINI_W + (count-1)*PAD;
    const rowLeftBase = RACK_CENTER_X - totalWidth/2;
    const arr=[];
    for(let i=0;i<count;i++){
      arr.push(rowLeftBase + i*(MINI_W+PAD));
    }
    return arr;
  }

  medalRowsTopFirst.forEach((row,topIndex)=>{
    const indexFromBottom = (totalMedalRows - 1 - topIndex);
    const rowTopPx = BOTTOM_ROW_Y_MEDALS - indexFromBottom * (MINI_H + PAD);

    const rowSortedForDisplay = [...row].reverse();
    const leftPositions = medalRowLeftPositions(rowSortedForDisplay.length);

    rowSortedForDisplay.forEach((entry,i)=>{
      const mimg=document.createElement('img');

      let relPath = entry.path;
      if(relPath.startsWith('images/')){
        relPath = relPath.slice('images/'.length);
      }
      mimg.src=ASSET(relPath);

      mimg.className='layer ribbonMini';
      mimg.style.display='block';

      const leftPx=leftPositions[i];
      const topPx =rowTopPx;

      mimg.style.left   = `${leftPx}px`;
      mimg.style.top    = `${topPx}px`;
      mimg.style.width  = `${MINI_W}px`;
      mimg.style.height = `${MINI_H}px`;

      mimg.onerror=()=>{};

      mimg.dataset.tooltipTitle = entry.id.replace(/_/g,' ').toUpperCase();
      mimg.dataset.tooltipReg   = "Miniature medal arrangement";
      mimg.dataset.tooltipWhy   = "Highest awards sit top row, centered.";

      uniformCanvas.appendChild(mimg);
    });
  });

  ensureRackCalibrationElement();
}

// ensure rack anchor is registered for calibration
function ensureRackCalibrationElement(){
  let el = document.getElementById("ribbonRack");
  if(!el){
    el = document.createElement("div");
    el.id = "ribbonRack";
    el.style.position="absolute";
    el.style.width="1px";
    el.style.height="1px";
    el.style.pointerEvents="none";
    uniformCanvas.appendChild(el);
  }
  el.style.left = rackBaseX + "px";
  el.style.top  = rackBaseY + "px";
  registerCalibratable("ribbonRack","Ribbon Rack",rackBaseX,rackBaseY,0);
}

/* ===========================
   DEVICE MULTI-APPLY UI
   =========================== */
function buildDevicePicker(){
  const wrap=by('devicePicker');
  wrap.innerHTML='';
  deviceList.forEach(id=>{
    const row=document.createElement('label');
    row.style.cssText="display:flex;align-items:center;gap:8px;font-size:12px;";
    row.innerHTML=`
      <input type="checkbox" data-device="${id}"/>
      <span>${deviceMeta[id].label}</span>
      <input type="number" min="1" max="10" value="1" data-qty="${id}" style="width:70px;margin-left:auto">
    `;
    wrap.appendChild(row);
  });
}
function readDevicePicker(){
  const wrap=by('devicePicker');
  const bundle={};
  wrap.querySelectorAll('input[type="checkbox"][data-device]').forEach(chk=>{
    const id=chk.getAttribute('data-device');
    if(chk.checked){
      const qty=parseInt(wrap.querySelector(`input[type="number"][data-qty="${id}"]`).value||"1",10);
      if(qty>0) bundle[id]=qty;
    }
  });
  return bundle;
}
function wireDeviceUI(){
  const applyBtn = by('deviceApplyModeBtn');
  const removeBtn= by('deviceRemoveModeBtn');
  const clearBtn = by('deviceClearSelectionBtn');

  applyBtn.addEventListener('click', ()=>{
    State.selectedDevices = readDevicePicker();
    const hasAny = Object.keys(State.selectedDevices).length>0;
    State.deviceApplyMode = hasAny;
    State.deviceRemoveMode = false;
    applyBtn.textContent = State.deviceApplyMode ? 'Apply Mode: ON' : 'Enable Apply Mode';
    applyBtn.classList.toggle('ghost', !State.deviceApplyMode);
    removeBtn.classList.add('ghost');
  });

  removeBtn.addEventListener('click', ()=>{
    State.deviceRemoveMode = !State.deviceRemoveMode;
    State.deviceApplyMode = false;
    removeBtn.textContent = State.deviceRemoveMode ? 'Remove Mode: ON' : 'Enable Remove Mode';
    removeBtn.classList.toggle('ghost', !State.deviceRemoveMode);
    applyBtn.textContent='Enable Apply Mode';
    applyBtn.classList.add('ghost');
  });

  clearBtn.addEventListener('click', ()=>{
    by('devicePicker').querySelectorAll('input[type="checkbox"]').forEach(c=>c.checked=false);
    by('devicePicker').querySelectorAll('input[type="number"]').forEach(n=>n.value=1);
    State.selectedDevices={};
    State.deviceApplyMode=false;
    State.deviceRemoveMode=false;
    applyBtn.textContent='Enable Apply Mode';
    removeBtn.textContent='Enable Remove Mode';
    applyBtn.classList.add('ghost');
    removeBtn.classList.add('ghost');
  });
}

/* ===========================
   BADGE RENDERING
   =========================== */
const badgeSlots = { OLPA:[], OLPU:[], OLP:[], ORP:[], ON:[], UN:[], LRP:[], LP:[], OVERSTACK:[] };
function resetBadgeSlots(){ Object.keys(badgeSlots).forEach(k=>badgeSlots[k]=[]); }

function isCadetAuthorized(id){ return allowedCadetBadges.has(id); }

function enforceExclusive(newId){
  exclusiveBadges.forEach(pair=>{
    if(pair.includes(newId)){
      pair.forEach(conf=>{
        if(conf!==newId && State.badges.includes(conf)){
          State.badges = State.badges.filter(b=>b!==conf);
        }
      });
    }
  });
}

function renderAllBadges(){
  [...uniformCanvas.querySelectorAll('.layer.badge')].forEach(n=>n.remove());
  resetBadgeSlots();
  if(!UI_AUTHZ[State.uniform]?.showBadges) return;

  const maxTotal=5;
  const applied=[];
  for(const id of State.badges){
    if(State.member==='cadet' && !isCadetAuthorized(id)){ continue; }
    if(applied.length>=maxTotal) break;
    placeBadgeByCategory(id);
    applied.push(id);
  }
}

function placeBadgeByCategory(id){
  const img=by(`badges-${id}`); 
  if(!img) return;

  let slot = badgeLocations[id] || 'UN';
  if(id==='nra_marksman_badge') slot='LRP';
  if(id==='model_rocketry_badge') slot='LP';

  const size = customBadgeSizes[id] || { width:60,height:25 };
  const spacing = 5;

  const baseRibbonY = getTopRibbonY();
  const RACK_CENTER_X = 293.5;

  const overRibbonSlots = new Set(['OLP','OLPU','OLPA','ORP']);
  if(overRibbonSlots.has(slot)){
    const stackIdx = badgeSlots.OVERSTACK.length;
    const bottomEdgeY = baseRibbonY - 25 - (stackIdx * (size.height + spacing));
    const topY = bottomEdgeY - size.height;
    const leftX = RACK_CENTER_X - (size.width / 2);

    const clone = img.cloneNode();
    clone.className='layer badge';
    clone.style.display='block';
    clone.style.top  = `${topY}px`;
    clone.style.left = `${leftX}px`;
    clone.style.width = `${size.width}px`;
    clone.style.height= `${size.height}px`;

    clone.dataset.tooltipTitle = id.replace(/_/g,' ').toUpperCase();
    clone.dataset.tooltipReg   = "Over-rack qualification badge";
    clone.dataset.tooltipWhy   = "Centered 25px above top ribbon row.";

    const elId = `badge-${slot}-${stackIdx}`;
    clone.id = elId;
    uniformCanvas.appendChild(clone);

    badgeSlots.OVERSTACK.push(id);

    registerCalibratable(elId, `${slot} Badge ${stackIdx}`, leftX, topY, 0);
    return;
  }

  if(!badgeSlots[slot]) badgeSlots[slot] = [];

  const yMap={
    ON:  baseRibbonY + 140,
    UN:  baseRibbonY + 180,
    LRP: baseRibbonY + 199,
    LP:  baseRibbonY + 244
  };
  const xMap={
    ON:  rackBaseX - 105,
    UN:  rackBaseX - 105,
    LRP: rackBaseX + (RIBBON_WIDTH*3) + 60,
    LP:  rackBaseX + (RIBBON_WIDTH*3) + 80
  };

  let y = yMap[slot] !== undefined ? yMap[slot] : (baseRibbonY+180);
  let x = xMap[slot] !== undefined ? xMap[slot] : (rackBaseX-105);

  if(slot==='ON'||slot==='UN'){
    const stackIdx = badgeSlots[slot].length;
    for(let i=0;i<stackIdx;i++){
      const prev=badgeSlots[slot][i];
      const ps=customBadgeSizes[prev]||{height:25};
      y+=ps.height+spacing;
    }
  }

  if(id==='model_rocketry_badge' && State.badges.includes('nra_marksman_badge')){
    y+=50;
  }

  const clone=img.cloneNode();
  clone.className='layer badge';
  clone.style.display='block';
  clone.style.top  = `${y}px`;
  clone.style.left = `${x}px`;
  clone.style.width = `${size.width}px`;
  clone.style.height= `${size.height}px`;

  clone.dataset.tooltipTitle = id.replace(/_/g,' ').toUpperCase();
  clone.dataset.tooltipReg   = "CAPR 39-1 badge placement";
  clone.dataset.tooltipWhy   = "Auto-placed relative to pockets / nameplate.";

  const stackPos = badgeSlots[slot].length;
  const elId = `badge-${slot}-${stackPos}`;
  clone.id = elId;

  uniformCanvas.appendChild(clone);

  badgeSlots[slot].push(id);

  registerCalibratable(elId, `${slot} Badge ${stackPos}`, x, y, 0);
}

/* ===========================
   PATCH RENDERING
   =========================== */
const patchSlots = { L_SHOULDER:[], R_SHOULDER:[], CHEST_LEFT:[], CHEST_RIGHT:[] };
function resetPatchSlots(){ Object.keys(patchSlots).forEach(k=>patchSlots[k]=[]); }

function planPatches(ids){
  resetPatchSlots();
  const capsPerUniform = {
    blues_a:{L_SHOULDER:1,R_SHOULDER:1,CHEST_LEFT:1,CHEST_RIGHT:1},
    blues_b:{L_SHOULDER:1,R_SHOULDER:1,CHEST_LEFT:1,CHEST_RIGHT:1},
    aviator:{L_SHOULDER:1,R_SHOULDER:1,CHEST_LEFT:1,CHEST_RIGHT:1},
    aviator_blazer:{L_SHOULDER:1,R_SHOULDER:1,CHEST_LEFT:0,CHEST_RIGHT:0},
    corporate_field:{L_SHOULDER:2,R_SHOULDER:2,CHEST_LEFT:1,CHEST_RIGHT:1},
    abu:{L_SHOULDER:2,R_SHOULDER:2,CHEST_LEFT:1,CHEST_RIGHT:1},
    flight_suit:{L_SHOULDER:2,R_SHOULDER:2,CHEST_LEFT:2,CHEST_RIGHT:2},
    semi_formal:{L_SHOULDER:0,R_SHOULDER:0,CHEST_LEFT:0,CHEST_RIGHT:0},
    mess_dress:{L_SHOULDER:0,R_SHOULDER:0,CHEST_LEFT:0,CHEST_RIGHT:0},
    polo:{L_SHOULDER:0,R_SHOULDER:0,CHEST_LEFT:0,CHEST_RIGHT:0}
  }[State.uniform] || {L_SHOULDER:1,R_SHOULDER:1,CHEST_LEFT:1,CHEST_RIGHT:1};

  for(const id of ids){
    const meta=PATCH_META[id]; if(!meta) continue;
    const hint=meta.slotHint || 'L_SHOULDER';
    const cap=capsPerUniform[hint]??0;
    if(cap===0) continue;
    if(patchSlots[hint].length>=cap) continue;
    patchSlots[hint].push(id);
  }
}

function renderPatches(){
  [...uniformCanvas.querySelectorAll('.layer.patch')].forEach(n=>n.remove());
  if(!UI_AUTHZ[State.uniform]?.showPatches) return;

  planPatches(State.patches);

  const coords={
    L_SHOULDER:{x:95,y:250,dy:80},
    R_SHOULDER:{x:505,y:250,dy:80},
    CHEST_LEFT:{x:260,y:420,dy:70},
    CHEST_RIGHT:{x:580,y:420,dy:70}
  };

  for(const slot of Object.keys(patchSlots)){
    const ids=patchSlots[slot];
    let {x,y,dy}=coords[slot]||{x:0,y:0,dy:70};
    ids.forEach((id,idx)=>{
      const meta=PATCH_META[id];
      const src = by('patch-'+id);
      const el  = (src?src.cloneNode():new Image());
      if(!src){ el.src=ASSET(meta.img); }

      el.className='layer patch';
      el.style.display='block';
      el.style.left =`${x - meta.w/2}px`;
      el.style.top  =`${y - meta.h/2}px`;
      el.style.width =`${meta.w}px`;
      el.style.height=`${meta.h}px`;
      el.onerror=()=>{};

      el.dataset.tooltipTitle = id.replace(/_/g,' ').toUpperCase();
      el.dataset.tooltipReg   = "Field/utility patch placement";
      el.dataset.tooltipWhy   = "Displayed on sleeve/chest per OCP/ABU/corporate field rules.";

      const elId=`patch-${slot}-${idx}`;
      el.id = elId;

      uniformCanvas.appendChild(el);

      registerCalibratable(elId, `Patch ${slot} ${idx}`, (x - meta.w/2), (y - meta.h/2), 0);

      y+=dy;
    });
  }
}

/* ===========================
   RANK / NAMEPLATE
   =========================== */
function renderRank(id){
  [...uniformCanvas.querySelectorAll('.layer.rank')].forEach(n=>n.remove());
  if(!id)return;

  const insigniaEl = by('ranks-'+id);
  if(!insigniaEl)return;

  const isOfficer = officerRanks.has(id);

  if(isOfficer){
    const boardSrc=ASSET('ranks/C/shoulder_board.png');
    const boardCfg={width:50,height:100};
    const insigniaCfg={width:32,height:32};
    const placements=[
      {left:350,top:160,rot:90,side:"right"},
      {left:100,top:160,rot:-90,side:"left"}
    ];
    placements.forEach(({left,top,rot,side})=>{
      const board=document.createElement('img');
      board.src=boardSrc;
      board.className='layer rank';
      board.style.display='block';
      board.style.left =`${left}px`;
      board.style.top  =`${top}px`;
      board.style.width =`${boardCfg.width}px`;
      board.style.height=`${boardCfg.height}px`;
      board.style.transform=`rotate(${rot}deg)`;
      board.style.transformOrigin='center center';
      board.dataset.tooltipTitle = id;
      board.dataset.tooltipReg   = "Officer shoulder board";
      board.dataset.tooltipWhy   = "Displayed for cadet/senior officer grades.";
      const boardId = `shoulder-${side}-board`;
      board.id = boardId;
      uniformCanvas.appendChild(board);

      registerCalibratable(boardId, `Shoulder Board ${side}`, left, top, rot);

      const ins=insigniaEl.cloneNode();
      ins.className='layer rank';
      ins.style.display='block';
      ins.style.left =`${left + (boardCfg.width/2 - insigniaCfg.width/2)}px`;
      ins.style.top  =`${top  + (boardCfg.height/2 - insigniaCfg.height/2)}px`;
      ins.style.width =`${insigniaCfg.width}px`;
      ins.style.height=`${insigniaCfg.height}px`;
      ins.style.transform=`rotate(${rot}deg)`;
      ins.style.transformOrigin='center center';
      ins.dataset.tooltipTitle = id;
      ins.dataset.tooltipReg   = "Rank insignia";
      ins.dataset.tooltipWhy   = "Placed on shoulder boards for officer grades.";
      const insId = `shoulder-${side}-insignia`;
      ins.id = insId;
      uniformCanvas.appendChild(ins);

      registerCalibratable(insId, `Shoulder Insignia ${side}`, parseFloat(ins.style.left), parseFloat(ins.style.top), rot);
    });
    return;
  }

  const size={w:60,h:60};
  const pos ={left:420,top:200};
  const icon=insigniaEl.cloneNode();
  icon.className='layer rank';
  icon.style.display='block';
  icon.style.left =`${pos.left}px`;
  icon.style.top  =`${pos.top}px`;
  icon.style.width =`${size.w}px`;
  icon.style.height=`${size.h}px`;
  icon.dataset.tooltipTitle = id;
  icon.dataset.tooltipReg   = "Enlisted/NCO rank placement";
  icon.dataset.tooltipWhy   = "Displayed directly on the coat / sleeve area.";
  const rankId="enlisted-rank";
  icon.id=rankId;
  uniformCanvas.appendChild(icon);

  registerCalibratable(rankId, "Enlisted Rank", pos.left, pos.top, 0);
}

function renderNameplate(){
  [...uniformCanvas.querySelectorAll('.layer.nameplate')].forEach(n=>n.remove());
  const baseRibbonY=getTopRibbonY();
  const npTop  = baseRibbonY + 150;
  const npLeft = rackBaseX - 120;

  const el=document.createElement('img');
  el.src=ASSET('nameplate/nameplate.png');
  el.className='layer nameplate';
  el.style.display='block';
  el.style.top  = npTop+'px';
  el.style.left = npLeft+'px';
  el.style.width='100px';
  el.style.height='20px';
  el.dataset.tooltipTitle="Nameplate";
  el.dataset.tooltipReg="CAPR 39-1 nameplate location";
  el.dataset.tooltipWhy="Centered on pocket / aligned per spec.";
  const npId="nameplate-el";
  el.id=npId;
  uniformCanvas.appendChild(el);

  registerCalibratable(npId, "Nameplate", npLeft, npTop, 0);
}

/* ===========================
   AUTH / UNIFORM SWITCHING
   =========================== */
function isUniformAllowedFor(uniformId, memberType){
  const btn = uniformListEl.querySelector(`.uniformOption[data-uniform-id="${uniformId}"]`);
  if(!btn) return false;
  const allowed=(btn.dataset.allowedFor||'').split(',').map(s=>s.trim());
  return allowed.includes(memberType);
}
function findFirstAllowedUniform(memberType){
  const opts=[...uniformListEl.querySelectorAll('.uniformOption')];
  for(const opt of opts){
    const allowed=(opt.dataset.allowedFor||'').split(',').map(s=>s.trim());
    if(allowed.includes(memberType)){
      return opt.dataset.uniformId;
    }
  }
  return null;
}
function applyMemberTypeToUniformOptions(){
  const opts=uniformListEl.querySelectorAll('.uniformOption');
  opts.forEach(opt=>{
    const allowed=(opt.dataset.allowedFor||'').split(',').map(s=>s.trim());
    const isAllowed=allowed.includes(State.member);

    if(isAllowed){
      opt.classList.remove('locked');
      opt.removeAttribute('data-locked-reason');
    }else{
      opt.classList.add('locked');
      let warnText='This Uniform Is Not Authorized For This Member Type';
      if(State.member==='cadet'){
        warnText="This Uniform Is Not Authorized For Cadets";
      }
      opt.setAttribute('data-locked-reason', warnText);
    }
  });
}
function highlightActiveUniformButton(){
  const opts=uniformListEl.querySelectorAll('.uniformOption');
  opts.forEach(opt=>{
    if(opt.dataset.uniformId===State.uniform){
      opt.style.outline=`2px solid var(--brand)`;
      opt.style.boxShadow=`0 0 0 3px rgba(0,40,85,.15)`;
      opt.style.background=`rgba(0,40,85,.05)`;
    }else{
      opt.style.outline='';
      opt.style.boxShadow='';
      opt.style.background='';
    }
  });
}

/* show/hide panels */
function updateAvailabilityUI(prevUniform){
  const auth = UI_AUTHZ[State.uniform] || {showRibbons:true,showPatches:true,showBadges:true};

  // groupPatches block is already its own panelBlock
  by('groupPatches').classList.toggle('hidden', !auth.showPatches);

  if(prevUniform && prevUniform!==State.uniform){
    applyAlternates(prevUniform, State.uniform);
  }

  populatePatchesRemove();
  populateBadgesRemove();
}

/* translate items when switching between field / non-field uniforms */
function applyAlternates(fromU,toU){
  const fromField=isFieldUniform(fromU);
  const toField  =isFieldUniform(toU);

  if(!fromField && toField){
    Object.entries(ALTERNATES.badgeToPatch).forEach(([badge,patch])=>{
      if(State.badges.includes(badge) && !State.patches.includes(patch)){
        State.patches.push(patch);
      }
    });
    Object.entries(ALTERNATES.ribbonToPatch).forEach(([rib,patch])=>{
      if(State.ribbons.find(r=>r.id===rib) && !State.patches.includes(patch)){
        State.patches.push(patch);
      }
    });
  } else if(fromField && !toField){
    Object.entries(ALTERNATES.patchToBadge).forEach(([patch,badge])=>{
      if(State.patches.includes(patch) && badge && !State.badges.includes(badge)){
        State.badges.push(badge);
      }
    });
    Object.entries(ALTERNATES.patchToRibbon).forEach(([patch,ribbon])=>{
      if(State.patches.includes(patch) && ribbon && !State.ribbons.find(r=>r.id===ribbon)){
        State.ribbons.push({id:ribbon,devices:{}});
      }
    });
  }

  if(State.member==='cadet'){
    State.badges = State.badges.filter(isCadetAuthorized);
  }
}

/* ===========================
   RENDER PIPELINE
   =========================== */
function fullRender(prevUniform){
  applyJacket();
  updateAvailabilityUI(prevUniform);

  renderPatches();
  renderRack();
  renderAllBadges();
  renderRank(State.rank);
  // nameplate is user-triggered only
}

function refreshUI(){
  memberSelect.value=State.member;
  jacketSelect.value=State.gender;
  assetBaseInput.value=State.assetBase;
  populateBadgesRemove();
  populatePatchesRemove();
  highlightActiveUniformButton();
  applyMemberTypeToUniformOptions();
  buildRibbonGrid(); // refresh ribbon cards + cadet filter visibility
}

/* ===========================
   RIBBON GRID UI (checkbox + device)
   =========================== */

function isRibbonSelected(id){
  return !!State.ribbons.find(r=>r.id===id);
}

function getRibbonDevice(ribbonId){
  const r = State.ribbons.find(x=>x.id===ribbonId);
  if(!r) return "";
  // pick first (or highest) device if only one? We manage per ribbon card with a single dropdown.
  // We'll just say: if exactly one device type present and qty>0, return that key. else "".
  const keys = Object.keys(r.devices||{});
  if(keys.length===1 && r.devices[keys[0]]>0){
    return keys[0];
  }
  return "";
}

function setRibbonDevice(ribbonId, deviceVal){
  const r = ensureRibbonObj(ribbonId);
  if(deviceVal===""){
    r.devices={};
  }else{
    r.devices={};
    // default qty 1
    r.devices[deviceVal]=1;
  }
}

function buildRibbonGrid(){
  const grid = document.getElementById('ribbonGrid');
  grid.innerHTML = "";

  const isCadet = (State.member === "cadet");

  // sort by precedence
  const sorted = [...RIBBONS].sort((a,b)=>a.precedence-b.precedence);

  sorted.forEach(rib=>{
    const hideForCadet = (isCadet && rib.smOnly);
    const card = document.createElement('div');
    card.className = "ribbonCard" + (hideForCadet ? " hidden":"");
    card.dataset.ribbonId = rib.id;
    card.dataset.ribbonName = rib.name;

    // header
    const header = document.createElement('div');
    header.className = "ribbonHeader";

    const left = document.createElement('div');
    left.className = "ribbonLeft";

    const boxWrap = document.createElement('div');
    boxWrap.className = "ribbonCheck";
    const check = document.createElement('input');
    check.type = "checkbox";
    check.checked = isRibbonSelected(rib.id);
    boxWrap.appendChild(check);

    const imgDiv = document.createElement('div');
    imgDiv.className = "ribbonImg";
    imgDiv.style.backgroundImage = `url(${ASSET(rib.img.replace(/^ribbons\//,"ribbons/"))})`;

    left.appendChild(boxWrap);
    left.appendChild(imgDiv);

    const nameDiv = document.createElement('div');
    nameDiv.className = "ribbonName";
    nameDiv.textContent = rib.name;

    header.appendChild(left);
    header.appendChild(nameDiv);

    // body / device select
    const body = document.createElement('div');
    body.className = "ribbonBody";

    const deviceField = document.createElement('div');
    deviceField.className = "deviceField";

    const dLabel = document.createElement('label');
    dLabel.textContent = "Device";
    const dSel = document.createElement('select');

    rib.devices.forEach(dev=>{
      const opt=document.createElement('option');
      opt.value=dev.value;
      opt.textContent=dev.label;
      dSel.appendChild(opt);
    });

    // set initial dropdown from State
    dSel.value = getRibbonDevice(rib.id);

    // checkbox change
    check.addEventListener('change',()=>{
      if(check.checked){
        ensureRibbonObj(rib.id);
        // keep device dropdown selection
        setRibbonDevice(rib.id, dSel.value);
      }else{
        // remove ribbon entirely
        State.ribbons = State.ribbons.filter(r=>r.id!==rib.id);
      }
      renderRack();
      renderAllBadges();
    });

    // device change
    dSel.addEventListener('change',()=>{
      if(!isRibbonSelected(rib.id)){
        // selecting a device auto-adds ribbon
        ensureRibbonObj(rib.id);
        check.checked = true;
      }
      setRibbonDevice(rib.id, dSel.value);
      renderRack();
    });

    deviceField.appendChild(dLabel);
    deviceField.appendChild(dSel);
    body.appendChild(deviceField);

    card.appendChild(header);
    card.appendChild(body);

    grid.appendChild(card);
  });
}

/* ===========================
   FLOATING RACK CALIB PANEL INIT
   =========================== */
function initCalibratorUI(){
  const tab          = by('calibratorTab');
  const arrow        = by('calibratorArrow');
  const panel        = by('calibratorPanel');

  const rackXRange   = by('rackXRange');
  const rackXNumber  = by('rackXNumber');
  const rackYRange   = by('rackYRange');
  const rackYNumber  = by('rackYNumber');

  const readX        = by('readX');
  const readY        = by('readY');
  const readSize     = by('readSize');

  rackXRange.value  = rackBaseX;
  rackXNumber.value = rackBaseX;
  rackYRange.value  = rackBaseY;
  rackYNumber.value = rackBaseY;
  readX.textContent = rackBaseX;
  readY.textContent = rackBaseY;
  readSize.textContent = RIBBON_WIDTH + "Ã—" + RIBBON_HEIGHT;

  let open=false;
  function togglePanel(){
    open=!open;
    panel.style.display=open?'block':'none';
    arrow.textContent=open?'â€¹':'â€º';
  }
  tab.addEventListener('click', togglePanel);

  function applyAndRerender(){
    readX.textContent=rackBaseX;
    readY.textContent=rackBaseY;
    renderRack();
    renderAllBadges();
    renderNameplate();
    renderRank(State.rank);
  }

  rackXRange.addEventListener('input', e=>{
    rackBaseX = parseInt(e.target.value,10);
    rackXNumber.value = rackBaseX;
    applyAndRerender();
  });
  rackXNumber.addEventListener('input', e=>{
    rackBaseX = parseInt(e.target.value,10) || 0;
    rackXRange.value = rackBaseX;
    applyAndRerender();
  });

  rackYRange.addEventListener('input', e=>{
    rackBaseY = parseInt(e.target.value,10);
    rackYNumber.value = rackBaseY;
    applyAndRerender();
  });
  rackYNumber.addEventListener('input', e=>{
    rackBaseY = parseInt(e.target.value,10) || 0;
    rackYRange.value = rackBaseY;
    applyAndRerender();
  });
}

/* ===========================
   EVENT WIRING
   =========================== */
memberSelect.addEventListener('change', ()=>{
  State.member = memberSelect.value;

  // if cadet picks a SM-only uniform, bounce to first allowed
  if(State.member==='cadet' && !isUniformAllowedFor(State.uniform,'cadet')){
    const fallback=findFirstAllowedUniform('cadet') || 'blues_a';
    const prevU=State.uniform;
    State.uniform=fallback;
    State.badges = State.badges.filter(isCadetAuthorized);

    // also purge SM-only ribbons that are currently selected
    State.ribbons = State.ribbons.filter(r=>{
      const meta=RIBBONS.find(x=>x.id===r.id);
      if(!meta) return true;
      if(meta.smOnly) return false;
      return true;
    });
    fullRender(prevU);
  }else{
    if(State.member==='cadet'){
      State.badges = State.badges.filter(isCadetAuthorized);
      State.ribbons = State.ribbons.filter(r=>{
        const meta=RIBBONS.find(x=>x.id===r.id);
        return !(meta && meta.smOnly);
      });
    }
    fullRender();
  }
  refreshUI();
});

jacketSelect.addEventListener('change', ()=>{
  State.gender=jacketSelect.value;
  fullRender();
});

uniformListEl.addEventListener('click', e=>{
  const btn=e.target.closest('.uniformOption');
  if(!btn) return;
  if(btn.classList.contains('locked')) return;
  const newUniform=btn.dataset.uniformId;
  const prevU=State.uniform;
  State.uniform=newUniform;
  fullRender(prevU);
  refreshUI();
});

by('applyJacket').addEventListener('click', ()=>{
  State.assetBase=(assetBaseInput.value||'images').trim()||'images';
  applyJacket();
});
assetBaseInput.addEventListener('change', ()=>{
  State.assetBase=(assetBaseInput.value||'images').trim()||'images';
  fullRender();
});

by('clearRibbons').addEventListener('click', ()=>{
  State.ribbons=[];
  buildRibbonGrid();
  renderRack();
  renderAllBadges();
});

by('toggleMini').addEventListener('change', e=>{
  State.forceMini = e.target.checked;
  renderRack();
  renderAllBadges();
});

buildDevicePicker();
wireDeviceUI();

by('addBadge')?.addEventListener('click', ()=>{
  const id=by('badgeSelect').value;
  if(State.member==='cadet' && !isCadetAuthorized(id)){
    alert('This badge is not authorized for cadets.');
    return;
  }
  enforceExclusive(id);
  if(!State.badges.includes(id)) State.badges.push(id);
  populateBadgesRemove();
  renderAllBadges();
});

by('removeBadge')?.addEventListener('click', ()=>{
  const id=by('removeBadgeSelect').value;
  State.badges=State.badges.filter(b=>b!==id);
  populateBadgesRemove();
  renderAllBadges();
});

by('addPatch')?.addEventListener('click', ()=>{
  const id=by('patchSelect').value;
  if(!State.patches.includes(id)) State.patches.push(id);
  populatePatchesRemove();
  renderPatches();
});

by('removePatch')?.addEventListener('click', ()=>{
  const id=by('removePatchSelect').value;
  State.patches=State.patches.filter(p=>p!==id);
  populatePatchesRemove();
  renderPatches();
});

by('addRank')?.addEventListener('click', ()=>{
  State.rank=by('rankSelect').value;
  renderRank(State.rank);
});

by('addNameplate')?.addEventListener('click', ()=>{
  renderNameplate();
});

by('downloadImage')?.addEventListener('click', ()=>{
  html2canvas(uniformCanvas,{scale:3,backgroundColor:'#ffffff'}).then(c=>{
    const a=document.createElement('a');
    a.download=`CAP_Uniform_${Date.now()}.png`;
    a.href=c.toDataURL();
    a.click();
  });
});

const toggleRibbonDragBtn = by('toggleRibbonDrag');
const logRibbonCoordsBtn  = by('logRibbonCoords');

toggleRibbonDragBtn.addEventListener('click', ()=>{
  State.ribbonDragMode = !State.ribbonDragMode;
  if(State.ribbonDragMode){
    toggleRibbonDragBtn.textContent = 'Disable Drag Mode';
    toggleRibbonDragBtn.classList.remove('ghost');
    uniformCanvas.classList.add('drag-mode-on');
  }else{
    toggleRibbonDragBtn.textContent = 'Enable Drag Mode';
    toggleRibbonDragBtn.classList.add('ghost');
    uniformCanvas.classList.remove('drag-mode-on');
  }
});

logRibbonCoordsBtn.addEventListener('click', ()=>{
  const data=[];
  uniformCanvas.querySelectorAll('.ribbonTile').forEach(tile=>{
    data.push({
      rid: tile.dataset.rid,
      left: tile.style.left,
      top: tile.style.top,
      width: tile.style.width,
      height: tile.style.height
    });
  });
  console.log('RIBBON_COORD_REPORT', data);
  alert('Ribbon coordinates logged to console.');
});

/* ===========================
   BOOTSTRAP
   =========================== */
(function init(){
  refreshUI();
  fullRender();
  initCalibratorUI();
  rebuildCalibrationUI();
  exportCalibrationJSON();
})();
</script>
</body>
</html>
